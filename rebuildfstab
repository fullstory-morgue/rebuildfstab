#!/bin/dash
#
# (Copyright  (C) 2007 sidux Foundation,Inc.
#             (C) 2007 Joaquim Boura <x-un-i@sidux.com>
#             (C) 2007 Kel Modderman <kel@otaku42.de>
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this package; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston,
# MA 02110-1301, USA.
#
# On Debian GNU/Linux systems, the text of the GPL license can be
# found in /usr/share/common-licenses/GPL.
#
#--------------------------------------------------------------

[ "$(id -u)" -ne 0 ] && exec su-me "$0" "$@"

#--------------------------------------------------------------
# the defaults

all_dev_names=""
dev_done=""
dump="0"
pass="1"
create_mount_points="no"
write_fstab="no"
fstab="/etc/fstab"
scan_opts=""

#--------------------------------------------------------------

usage()
{
	echo ""
	echo "$(basename $0) can (re)create the /etc/fstab file and can create"
	echo "missing mountpoints in /media"
	echo ""
	echo "By default $(basename $0) prints fstab to stdout, and does not"
	echo "(re)create mountpoints"
	echo ""
	echo "-h|--help			print this help"
	echo "-w|--write-fstab		(re)create the fstab file"
	echo "-m|--make-mountpoints	(re)create mountpoints in /media"
	echo "-U|--uuids		use UUID's for mount names when possible"
	echo "-L|--labels		use LABELS's for mount names when possible"
	echo "-g|--group <groupname>	group to create special mount options for"
	echo "-u|--user <username>	user to create special mount options for"
	echo "-f|--fstab <file>		target file to write output to"
	echo "-d|--debug		debug sh code execution"
	echo ""
}
#--------------------------------------------------------------

bad_arg_value()
{
	usage
	exit 1
}

#--------------------------------------------------------------

out()
{
	if [ "$write_fstab" = "yes" ]; then
		printf "${@}" >> ${fstab}
	else
		printf "$@"
	fi
}

#--------------------------------------------------------------

create_media_entry()
{
	mypoint=$1
	if [ "$create_mount_points" = "yes" ] ; then
		[ -d "$mypoint" ] || mkdir -p "$mypoint" 2>/dev/null
	fi
}

#------------------------------------------------------------
#output $uuid $point $fstype $options $dump $pass

output()
{
	if [ "$to_file" = "true" ]; then
		out "%s\t%s\t%s\t%s\t%s %s\n" $1 $2 $3 $4 $5 $6 >> ${TO_FILE}
	else
		out "%s\t%s\t%s\t%s\t%s %s\n" $1 $2 $3 $4 $5 $6
	fi
}

#--------------------------------------------------------------

start()
{
	out "%s\n" "# /etc/fstab: static file system information" 
	out "%s\n" "#"
	out "%s\t\t\t%s\t%s\t%s\t%s\n\n" "# <file system>" "<mount point>" "<type>" "<options>" "<dump> <pass>"
}

#--------------------------------------------------------------
# print_outcdrom $name $point $CDR $CDRW $DVD $DVD_R $DVD_RAM

print_outcdrom()
{
	fstype="udf,iso9660"
	options="user,noauto"
 	output $1 $2 $fstype $options 0 0
}

#--------------------------------------------------------------
# return 0 if the device is a removable one
# firewire and usb are removable ones...

is_device_removable()
{
	curdev=$(echo $1 |cut -d / -f 3 |sed 's%\(...\).*$%\1%')
	ls -l /sys/block/$curdev/device | grep -q -e usb -e fw 
	# return 0 is the device is removable ...
	ret=$?
	return $ret
}
#--------------------------------------------------------------

devs_not_in_media()
{
	# Mounted Partitions not in /media, formated as dev:pnt
	mntpnt=$(mount |grep -v -e devpts -e tmpfs -e proc -e sysfs \
		-e udev -e media -e none -e fuse |awk '{print $1":"$3}')

	for i in ${mntpnt}; do
		unset dev pnt dev_name fstype options
		
		dev=$(echo $i |cut -d ":" -f1)
		pnt=$(echo $i |cut -d ":" -f2)
		
		# clobber positional variables
		[ "$#" != 0 ] && shift $#
		
		# assign positional parameters: ($1, $2, $3) = ($dev_name, $mntpnt, $fstype)
		set -- $(scanpartitions $scan_opts $dev 2>/dev/null)
		
		# 3 positional parameters were not assigned above, via scanpartitions
		# we cannot handle this device, process next possible device
		[ "$#" != 3 ] && continue
		
		dev_name="$1"

		if test -z "$all_dev_names" ; then
			# the first one
			all_dev_names="$dev_name"
			dev_done="$dev"
		else
			if echo "$all_dev_names" | grep -q "$dev_name" ; then
				# comment out device with duplicate uuid
				dev_name="# $dev_name"
			else 
				# this is a new one so add it into the list
				all_dev_names="$all_dev_names $dev_name"
			fi
			dev_done="$dev_done $dev"
		fi

		fstype="$3"
		options="defaults"

		output $dev_name $pnt $fstype $options $dump $pass
	done
	out "\n"
}

#--------------------------------------------------------------

devs_in_media()
{
	# now we scan all existing partitions, as detected by scanpartitions
	
	unset iocs nls 
	
	if [ "$(locale charmap)" = "UTF-8" ]; then
		iocs=",iocharset=utf8"
		nls=",nls=utf8"
	fi

	while read dev_name point fstype relax; do
		
		# determine actual device node
		case "$dev_name" in
			LABEL=*|UUID=*)
				dev=$(findfs $dev_name)
				;;
			/dev/disk/by-*)
				dev=$(readlink -f $dev_name)
				;;
			/dev/*)
				dev="$dev_name"
				;;
			*)
				# skip if not a UUID, LABEL or /dev/ node
				continue
				;;
		esac
		
		# skip if we failed to locate a device node
		test -b "$dev" || continue 

		if echo "$dev_done" | grep -q "$dev" ; then
			# skip this one ...
			:
		else
			if ! is_device_removable $dev ; then

				create_media_entry $point

				options="noauto,users,exec"

				case "$fstype" in
					ntfs)
						options="${options},ro,umask=000${nls}"
						[ -n "$user" ]  && options="$options,uid=$user"
						[ -n "$group" ] && options="$options,gid=$group"
						;;
					msdos)
						options="${options},umask=000,quiet${iocs}"
						[ -n "$user" ]  && options="$options,uid=$user"
						[ -n "$group" ] && options="$options,gid=$group"
						;;
					vfat)
						options="${options},umask=000,shortname=mixed,quiet${iocs}"
						[ -n "$user" ]  && options="$options,uid=$user"
						[ -n "$group" ] && options="$options,gid=$group"
						;;
					swap)
						options="sw"
						;;
					*)
						;;
				esac

				if echo "$all_dev_names" | grep -q "$dev_name" ; then
					# it's a already used uuid so fallback to dev
					dev_name="# $dev_name"
				else 
					# this is a new one so add it into the list
					all_dev_names="$all_dev_names $dev_name"
				fi
				
				dev_done="$dev_done $dev"
				
				out "%s\n" "# added by sidux"
				output $dev_name $point $fstype $options $dump $pass
				out "\n"
			fi
		fi
	done <<EOT
$(/usr/sbin/scanpartitions $scan_opts 2>/dev/null)
EOT
}

#--------------------------------------------------------------

optical_devs()
{
	for i in /dev/cdrom*; do
		test -b "$i" || continue

		dev="$i"
		point="/media/$(basename $dev)"

		create_media_entry $point

		out "%s\n" "# added by sidux"
		print_outcdrom $dev $point
		out "\n"
	done
}

#--------------------------------------------------------------

floppy_devs()
{
	fstype="auto"
	options="rw,user,noauto"
	dump=0
	pass=0

	for device in $(echo /sys/block/fd*); do
		if [ -d "${device}" ] ; then

			devnr="$(echo $device | sed s/.*fd//g)"
			point="/media/floppy${devnr}"
			dev="/dev/fd${devnr}"

			create_media_entry $point

			out "%s\n" "# added by sidux"
			output $dev $point $fstype $options $dump $pass
			out "\n"
		fi
	done
}

#--------------------------------------------------------------
# preparation
#--------------------------------------------------------------

TEMP=`getopt -o df:hLmwg:u:U --long debug,ftsab:,help,labels,make-mountpoints,write-fstab,group:,user:,uuids \
     -n  "$(basename $0)" -- "$@"`

if [ $? != 0 ] ; then echo "Terminating..." >&2 ; exit 1 ; fi

# Note the quotes around `$TEMP': they are essential!
eval set -- "$TEMP"

while true ; do
	case "$1" in
		-d|--debug)
			set -x
			shift
			;;
		-f|--fstab)
			fstab="$2"
			shift 2
			;;
		-h|--help)
			usage
			exit 0
			;;
		-w|--write-fstab) 
			write_fstab="yes"
			shift
			;;
		-L|--labels)
			if [ "$scan_opts" ]; then
				scan_opts="${scan_opts} --labels"
			else
				scan_opts="--labels"
			fi
			shift
			;;
		-m|--make-mountpoints)
			create_mount_points="yes"
			shift
			;;
		-g|--group)
			group="$2"
			shift 2
			;;
		-u|--user)
			user="$2"
			shift 2
			;;
		-U|--uuids)
			if [ "$scan_opts" ]; then
				scan_opts="${scan_opts} --uuids"
			else
				scan_opts="--uuids"
			fi
			shift
			;;
		--) 
			shift
			break ;;
		*)
			echo "Internal error!"
			exit 1
			;;
	esac
done

if [ "$write_fstab" = "yes" ]; then
	test -e ${fstab} && mv -f ${fstab} ${fstab}.old
fi

#--------------------------------------------------------------
# do the main job
#--------------------------------------------------------------

start

devs_not_in_media

devs_in_media

optical_devs

floppy_devs

exit 0
