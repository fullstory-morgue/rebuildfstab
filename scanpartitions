#!/usr/bin/perl -w
#
# Copyright (C) 2007 Kel Modderman <kel@otaku42.de>
#		     Michiel de Boer <locsmif@kanotix.com>
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this package; if not, write to the Free Software 
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, 
# MA 02110-1301, USA.
#
# On Debian GNU/Linux systems, the text of the GPL license can be
# found in /usr/share/common-licenses/GPL.

use strict;
use Getopt::Long qw(:config bundling no_auto_abbrev);

die("Must be root...\n") unless $> == 0;

my (%partitions, %uuid, %label);
my ($debug, $uuids, $labels) = (0, 0, 0);

sub dbg {
	return unless $debug;
	
	if (ref $_[0]) {
		print STDERR Dumper($_[0]);
	}
	else {
		printf(STDERR "%s\n", $_[0]);
	}
}

sub vol_id {
	return unless -x '/lib/udev/vol_id';

	my $vol = shift;
	if ($vol !~ m|^/dev/|) {
		$vol = "/dev/" . $vol;
	}
	return unless -b $vol;

	open(my $fh, "-|", "/lib/udev/vol_id $vol 2>/dev/null");
	while (<$fh>) {
		chomp;
		dbg($_);
		m/^ID_FS_([^=]+)=(.+)$/ and $partitions{$vol}{lc($1)} = $2;
	}
	close($fh);
}

sub parse_partitions {
	return unless -f '/proc/partitions';

	open(my $fh, '<', '/proc/partitions');
	while (<$fh>) {
		chomp;
		dbg($_);
		if(/\s+(\d+)\s+(\d+)\s+(\d+)\s+(.+)/) {
			next if $4 =~ /^(ram|cloop|loop)[0-9]*/;
			vol_id($4);
		}
	}
	close($fh);
}

GetOptions(
	"d|debug" => sub { $debug++ },
	"u|uuids" => sub { $uuids++ },
	"l|labels" => sub { $labels++ },
);

if ($debug) {
	require Data::Dumper;
	import Data::Dumper;
}

if (@ARGV) {
	vol_id($_) foreach (sort @ARGV);
}
else {
	parse_partitions();
}

dbg(\%partitions);

foreach my $p (sort keys %partitions) {
	my ($pp, $mntdev, $mntpnt) = ($partitions{$p}, undef, undef);
	dbg("\$p = '$p'"); dbg(\%{$partitions{$p}});

	next if $$pp{'usage'} !~ /(filesystem|other)/;
	next if $$pp{'type'} =~ /(unknown|iso9660|udf|squashfs)/;

	if ($uuids and $$pp{'uuid'}) {
		if (defined $uuid{$$pp{'uuid'}}) {
			printf(STDERR "Duplicate UUID (%s): %s\n", $p, $$pp{'uuid'});
		}
		else {
			# add to uuid hash
			$uuid{$$pp{'uuid'}} = 1;
			# form UUID string for fstab
			$mntdev = ($$pp{'type'} =~ /^(vfat|msdos|ntfs)$/) ?
				"/dev/disk/by-uuid/" . $$pp{'uuid'} :
				"UUID=" . $$pp{'uuid'};
		}
	}

	if ($labels and $$pp{'label_safe'}) {
		if (defined $label{$$pp{'label_safe'}}) {
			printf(STDERR "Duplicate LABEL (%s): %s\n", $p, $$pp{'label_safe'});
		}
		else {
			# add to label hash
			$label{$$pp{'label_safe'}} = 1;
			# form LABEL fstab string
			$mntdev = ($$pp{'type'} =~ /^(vfat|msdos|ntfs)$/) ?
				"/dev/disk/by-label/" . $$pp{'label_safe'} : 
				"LABEL=" . $$pp{'label_safe'};
			# mountpoint name is label
			$mntpnt = '/media/' . $$pp{'label_safe'};
		}
	}

	# device name as default/fallback
	$mntdev ||= $p;

	# mountpoint name, none for swap, /media/XXX for everything else
	$mntpnt = 'none' if $$pp{'type'} eq 'swap';
	($mntpnt ||= '/media/' . $p) =~ s|/dev/||;

	dbg("\$mntdev = '$mntdev'; \$mntpnt = '$mntpnt'");

	printf("%s %s %s\n", $mntdev, $mntpnt, $$pp{'type'});
}
