#!/usr/bin/perl -w
#
# Copyright (C) 2007 Kel Modderman <kel@otaku42.de>
#		     Michiel de Boer <locsmif@kanotix.com>
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this package; if not, write to the Free Software 
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, 
# MA 02110-1301, USA.
#
# On Debian GNU/Linux systems, the text of the GPL license can be
# found in /usr/share/common-licenses/GPL.

use strict;
use Getopt::Long qw(:config bundling no_auto_abbrev);
use Data::Dumper;

die("Must be root...\n") unless $> == 0;

my (%partitions, %uuid, %label);
my ($debug, $uuids, $labels) = (0, 0, 0);

sub vol_id {
	return unless -x '/lib/udev/vol_id';

	my $vol = shift;
	if ($vol !~ m|^/dev/|) {
		$vol = "/dev/" . $vol;
	}
	return unless -b $vol;

	open(my $fh, "-|", "/lib/udev/vol_id $vol 2>/dev/null");
	while (<$fh>) {
		print if $debug > 0;
		chomp($_);
		if (/^ID_FS_([^=]+)=(.+)$/) {
			$partitions{$vol}{lc($1)} = $2;
		}
	}
	close($fh);
}

sub parse_partitions {
	return unless -f '/proc/partitions';

	open(my $fh, '<', '/proc/partitions');
	while (<$fh>) {
		print if $debug > 0;
		if(/\s+(\d+)\s+(\d+)\s+(\d+)\s+(.+)/) {
			next if $4 =~ /^(ram|cloop|loop)[0-9]*/;
			vol_id($4);
		}
	}
	close($fh);
}

GetOptions(
	"d|debug" => sub { $debug++ },
	"u|uuids" => sub { $uuids++ },
	"l|labels" => sub { $labels++ },
);

if (@ARGV) {
	vol_id($_) foreach (sort @ARGV);
}
else {
	parse_partitions();
}

print Dumper(\%partitions) if $debug > 0;

foreach my $p (sort keys %partitions) {
	my $pp = $partitions{$p};
	print Dumper(\$pp) if $debug > 0;

	next if $$pp{'usage'} !~ /(filesystem|other)/;
	next if $$pp{'type'} =~ /(unknown|iso9660|udf|squashfs)/;

	my %fstab = ();

	if ($uuids > 0 and $$pp{'uuid'}) {
		if (defined $uuid{$$pp{'uuid'}}) {
			printf(STDERR "Duplicate UUID (%s): %s\n", $p, $$pp{'uuid'});
		}
		else {
			# add to uuid hash
			$uuid{$$pp{'uuid'}} = 1;
			# form UUID string for fstab
			$fstab{'mntdev'} = ($$pp{'type'} =~ /^(vfat|msdos|ntfs)$/) ?
				"/dev/disk/by-uuid/" . $$pp{'uuid'} :
				"UUID=" . $$pp{'uuid'};
		}
	}

	if ($labels > 0 and $$pp{'label_safe'}) {
		if (defined $label{$$pp{'label_safe'}}) {
			printf(STDERR "Duplicate LABEL (%s): %s\n", $p, $$pp{'label_safe'});
		}
		else {
			# add to label hash
			$label{$$pp{'label_safe'}} = 1;
			# form LABEL fstab string
			$fstab{'mntdev'} = ($$pp{'type'} =~ /^(vfat|msdos|ntfs)$/) ?
				"/dev/disk/by-label/" . $$pp{'label_safe'} : 
				"LABEL=" . $$pp{'label_safe'};
			# mountpoint name is label
			$fstab{'mntpnt'} = '/media/' . $$pp{'label_safe'};
		}
	}

	# device name as default/fallback
	$fstab{'mntdev'} = $p unless exists $fstab{'mntdev'};

	# mountpoint name, none for swap, /media/XXX for everything else
	$fstab{'mntpnt'} = 'none' if $$pp{'type'} eq 'swap';
	$fstab{'mntpnt'} = '/media/' . $p unless defined $fstab{'mntpnt'};
	$fstab{'mntpnt'} =~ s|/dev/||;

	# for completeness
	$fstab{'fstype'} = $$pp{'type'};
	print Dumper(\%fstab) if $debug > 0;

	printf("%s %s %s\n", $fstab{'mntdev'}, $fstab{'mntpnt'}, $fstab{'fstype'});
}
