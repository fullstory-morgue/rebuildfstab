#!/usr/bin/perl -w
#
# Copyright (C) 2007 Kel Modderman <kel@otaku42.de>
#		     Michiel de Boer <locsmif@kanotix.com>
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this package; if not, write to the Free Software 
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, 
# MA 02110-1301, USA.
#
# On Debian GNU/Linux systems, the text of the GPL license can be
# found in /usr/share/common-licenses/GPL.

use strict;
use Getopt::Long qw(:config bundling no_auto_abbrev);
#use Data::Dump qw(dump);

die("Must be root...\n") unless $> == 0;

my (%partitions, %uuid, %label, %fstab);
my ($debug, $uuids, $labels) = (0, 0, 0);

sub vol_id {
	return unless -x '/lib/udev/vol_id';

	my $vol = shift;
	if ($vol !~ m|^/dev/|) {
		$vol = "/dev/$vol";
	}
	return unless -b $vol;

	open(my $fh, "-|", "/lib/udev/vol_id $vol 2>/dev/null");
	while (<$fh>) {
		print if $debug > 0;
		chomp($_);
		if (/^ID_FS_([^=]+)=(.+)$/) {
			$partitions{$vol}{lc($1)} = $2;
		}
	}
	close($fh);
}

sub parse_partitions {
	return unless -f '/proc/partitions';

	open(my $fh, '<', '/proc/partitions');
	while (<$fh>) {
		print if $debug > 0;
		if(/\s+(\d+)\s+(\d+)\s+(\d+)\s+(.+)/) {
			next if $4 =~ /^(ram|cloop|loop)[0-9]*/;
			vol_id($4);
		}
	}
	close($fh);
}

GetOptions(
	"d|debug" => sub { $debug++ },
	"u|uuids" => sub { $uuids++ },
	"l|labels" => sub { $labels++ },
);

if (@ARGV) {
	vol_id($_) foreach (sort @ARGV);
}
else {
	parse_partitions();
}

#dump(\%partitions);

PART: foreach my $p (sort keys %partitions) {
	next if $partitions{$p}{'usage'} !~ /(filesystem|other)/;
	next if $partitions{$p}{'type'} =~ /(unknown|iso9660|udf|squashfs)/;

	%fstab = ();
	
	if ($uuids > 0 and $partitions{$p}{'uuid'}) {
		if (defined $uuid{$partitions{$p}{'uuid'}}) {
			printf(STDERR "Duplicate UUID: %s\n", $partitions{$p}{'uuid'});
			next PART;
		}
		# add to uuid hash
		$uuid{$partitions{$p}{'uuid'}} = 1;
		# form UUID string for fstab
		$fstab{'mntdev'} = ($partitions{$p}{'type'} =~ /^(vfat|msdos|ntfs)$/) ?
			"/dev/disk/by-uuid/" . $partitions{$p}{'uuid'} :
			"UUID=" . $partitions{$p}{'uuid'};
	}

	if ($labels > 0 and $partitions{$p}{'label_safe'}) {
		if (defined $label{$partitions{$p}{'label_safe'}}) {
			printf(STDERR "Duplicate LABEL: %s\n", $partitions{$p}{'label_safe'});
			next PART;
		}
		# add to label hash
		$label{$partitions{$p}{'label_safe'}} = 1;
		# form LABEL fstab string
		$fstab{'mntdev'} = ($partitions{$p}{'type'} =~ /^(vfat|msdos|ntfs)$/) ?
			"/dev/disk/by-label/" . $partitions{$p}{'label_safe'} : 
			"LABEL=" . $partitions{$p}{'label_safe'};
		# mountpoint name is label
		$fstab{'mntpnt'} = '/media/' . $partitions{$p}{'label_safe'};
	}

	# device name as default/fallback
	$fstab{'mntdev'} = $p unless exists $fstab{'mntdev'};

	# mountpoint name, none for swap, /media/XXX for everything else
	$fstab{'mntpnt'} = 'none' if $partitions{$p}{'type'} eq 'swap';
	$fstab{'mntpnt'} = '/media/' . $p unless defined $fstab{'mntpnt'};
	$fstab{'mntpnt'} =~ s|/dev/||;

	#dump(\%fstab);

	printf("%s %s %s\n", $fstab{'mntdev'}, $fstab{'mntpnt'}, $partitions{$p}{'type'});
}
